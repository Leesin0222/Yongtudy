상속시에는 기본적으로 슈퍼클래스에 있는 함수와 같은 이름과 형태를 가진 함수는 서브 클래스에서는 만들 수 없다.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c9d16576-829c-40d5-94fa-56e779953d44/1.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c9d16576-829c-40d5-94fa-56e779953d44/1.png)

하지만 슈퍼클래스에서 허용만 한다면 **오버라이딩(overriding)**이라는 방법으로 서브 클래스에서 같은 이름과 형태로 된 함수의 내용을 다시 구현할 수 있는데 오버라이딩을 사용해보자.

먼저 상속이 가능하게 open된 Animal 클래스를 만들고 클래스 내에 음식을 먹을 때 실행할 eat함수를 만들어보자. 그 안에서는 "음식을 먹습니다"라고 출력해보자 그리고 Tiger 클래스를 만들어 이 클래스를 상속 받아보자 이 상태에서 Tiger의 인스턴스를 만들고 eat을 실행해보면 "음식을 먹습니다"를 출력하는 것을 볼 수 있다.

```kotlin
fun main() {
   var t = Tiger()
   
   t.eat()
}
open class Animal {
    fun eat() {
        println("음식을 먹습니다")
    }
}
class Tiger : Animail()
```

그런데 Tiger 클래스에서는 "음식을 먹습니다" 대신 "고기를 먹습니다"라고 출력하고 싶다고 해보자 하지만 이미 eat함수는 Animal에서 "음식을 먹습니다"라고 구현되어 있기 때문에 서브 클래스에서는 함수를 재구현할 수 없다. 이 때, Animal 클래스에서 eat함수 앞에 open이 붙어 있었다면 Tiger에서 재구현이 허용되는데 슈퍼클래스에서 'open'이 붙은 함수는 서브클래스에서 'override'를 붙여 재구현 하면 된다. 여기서는 "고기를 먹습니다"를 대신 출력하도록 바꿔보자. 이제 Tiger에서 eat을 다시 수행해보면 "음식을 먹습니다"대신 "고기를 먹습니다"를 출력하는 것을 볼 수 있다

```kotlin
fun main() {
   var t = Tiger()
   
   t.eat()
}
open class Animal {
    open fun eat() {
        println("음식을 먹습니다")
    }
}
class Tiger : Animail() {
     override fun eat() {
          println("고기를 먹습니다")
     }
}
```

이 사례에서는 이미 슈퍼클래스에서 구현이  끝난 함수를 오버라이딩을 통해 재구현하는 경우를 말했었는데 이번엔 오버라이딩과 다르게 슈퍼클래스에서는 함수의 구체적인 구현은 없고 단지 Animal의 모든 서브클래스는 eat이라는 함수가 '반드시 있어야 한다'는 점만 명시하여 각 서브클래스가 비어있는 함수의 내용을 필요에 따라 구현하도록 하려면 **추상화(abstraction)**이라는 개념이 필요하다 추상화는 선언부만 있고 기능이 구현되지 않은 추상함수(abstraction function) 그리고 추상함수를 포함하는 추상클래스(abstraction class)라는 요소로 구성된다.

그럼 추상함수를 포함한 추상클래스를 만들고 서브클래스에서 상속받아 구현까지 하는 과정을 알아보자 이번엔 Animal클래스를 다시 만들되 그 앞에 abstract를 붙여준다. 그리고 추상함수인 eat함수를 만드는데 그 앞에도 abstract를 붙이고 함수의 내용은 적지 않는다.(*추상함수는 비어있는 껍데기라고 생각하세요) 또한 일반 함수로 냄새를 맡는 sniff라는 함수를 추가하고 킁킁거리도록 해보자 이렇게 abstract를 붙인 추상클래스는 일부 함수가 구현되지 않은 '미완성 클래스'이기 떄문에 단독으로는 인스턴스를 만들 수 없다 따라서 반드시 서브클래스에서 상속을 받아 abstract표시가 된 함수들을 구현해줘야 하는데 Rabbit 이라는 클래스를 만들어 Animal을 상속받고 eat이라는 추상함수의 실제 동작이 되는 구현부를 만들어보자.(*override키워드를 잊지 말자!) 여기서는 "당근을 먹습니다"를 출력하도록 해보자 Rabbit의 인스턴스를 만들어 eat과 sniff를 수행하도록 하면 당근을 먹고 킁킁거리는 토끼를 볼 수가 있다.

```kotlin
fun main() {
    var r = Rabbit()
    
    r.eat()
    r.sniff()
}
abstract class Animal {
     abstract fun eat()
     fun sniff() {
         println("킁킁")
     }
}
class Rabbit : Animal() {
  override fun eat() {
     println("당근을 먹는다")
  }
}
```

그런데, 추상화를 하는 또 다른 방법이 있다. 바로 **인터페이스(interface)**이라는 기능이다. 혹시 다른 언어에서 인터페이스를 배웠다면 알겠지만 원래 인터페이스는 추상함수로만 이루어 져 있는 '순수 추상화 기능'을 말하는 것이라고 알텐데 코틀린에서는 인터페이스 역시 추상함수와 일반함수 모두를 가질 수 있다

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3a660d35-9cb8-4403-ae9f-5fb878214630/5.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3a660d35-9cb8-4403-ae9f-5fb878214630/5.png)

다만 추상함수는 생성자를 가질 수 있는 반면 인터페이스는 생성자를 가질 수는 없으며 인터페이스에서 구현부가 있는 함수는 open함수로 간주하고 구현부가 없는 함수는 abstract함수로 간주한다. 별도의 키워드가 없어도 포함된 모든 함수를 서브클래스에서 구현 및 재정의가 가능하다 . 또한 한 번에 여러 인터페이스를 상속 받을 수 있으므로 좀 더 유연한 설계가 가능하다.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/13a97341-70b3-4253-9461-f0cfe774aa03/4.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/13a97341-70b3-4253-9461-f0cfe774aa03/4.png)

그럼 인터페이스 2개를 한 번에 상속받는 클래스를 만들어보자 먼저 Runner라는 인터페이스를 만들고 run이라는 함수를 구현부 없이 만들어보자 또한 Eater이라는 인터페이스를 만들고 eat이라는 함수를 "음식을 먹습니다"를 출력하도록 해보자. 이제  Dog라는 클래스로 두 인터페이스를 상속받으려면 클래스 선언 뒤에 콜론을 붙이고 쉼표로 두 인터페이스를 구분하여 표기해주면 된다. 그리고 구현부가 없던 run함수에는 override를 붙여 "우다다다 뜁니다"를 출력해하도록 구현해주고 이미 구현이 있는 eat이라는 함수는 override를 붙여 "허겁지겁 먹습니다"를 출력하도록 재구현해준다. 이렇게 하면 Dog는 두 인터페이스의 형식들을 모두 물려받아 사용하는 서브클래스가 되는 것이다.

```kotlin
fun main() {
    var d = Dog()
 
    d.run()
    d.eat()
}
interface Runner {
    fun run()
}
interface Eater {
    fun eat()
        println("음식을 먹습니다")
    }
}
class Dog : Runner, Easter() {
  override fun run() {
      println("우다다다 뜁니다")
   }
   override fun eat() {
      println("허겁지겁 먹습니다")
   }
}
```

한 가지 주의해야 할 점은 '여러개'의 인터페이스나 클래스에서 같은 이름과 형태를 가진 함수를 구현하고 있다면 서브클래스에서는 혼선이 일어나지 않도록 반드시 오버라이딩하여 재구현 해주어야 한다.

다시 한 번 정리하자면 오버라이딩은 이미 구현이 끝난 함수의 기능을 서브클래스에서 변경해야 할 때 그리고 추상화는 형식만 선언하고  실제 구현은 서브클래스에 일임할 때 사용하는 기능이며 인터페이스는 서로 다른 기능들을 여러개 물려주어야 할 때 유용한 기능이다
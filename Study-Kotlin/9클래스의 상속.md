**상속(inheritance)**은 왜 필요할까요? 실무자 입장에서 보았을 때 상속이 필요한 경우는 두 가지가 있다.

- 먼저 이미 존재하는 클래스를 확장하여 새로운 속성이나 함수를 추가 한 클래스를 만들어야 할 때

  ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/10faa51d-3e3c-40f9-8024-a96df5deec9f/1.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/10faa51d-3e3c-40f9-8024-a96df5deec9f/1.png)

- 여러개의 클래스를 만들었는데 클래스들의 공통점을 뽑아 코드 관리를 편하게 할 때 사용한다.

  ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/03dd4830-d99d-4e3a-b039-6a85b545d175/2.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/03dd4830-d99d-4e3a-b039-6a85b545d175/2.png)

여기서 속성과 함수를 물려주는 쪽을 슈퍼 클래스 물려 받는 쪽을 서브 클래스라고 부른다

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3b69d474-23ed-47eb-aa82-7a787d9a8391/3.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3b69d474-23ed-47eb-aa82-7a787d9a8391/3.png)

그럼 상속을 구현해 볼까? 일단 애완동물을 관리하는 Animal 클래스를 만들어보자 여기에는 이름,나이,종류 등의 기본 정보가 들어간다고 해보자. 함수도 하나 추가해보자 동물의 정보를 알 수 있는 introduce 함수를 추가하고 이름과 나이를 출력하게 해보자.

```kotlin
fun main() { 

}
class Animal (var name:String, var age:Int, var type:String)
{
   fun introduce() {
       println ("저는 ${type}이고 ${name}이고, ${age}살 입니다.")
   }
}
```

이제 Animal 클래스를 상속받아 Dog와 Cat클래스로 확장해볼텐데 현재 Animal 클래스는 'open'상태가 아니기 때문에 (*코틀린은 상속금지가 기본값이다) 상속을 받을 수 없다. open은 클래스가 상속될 수 있도록 클래스 선언 시 붙여줄 수 있는 키워드인데 따라서 open을 Animal 클래스 앞에 붙여주고 이를 상속받는 Dog클래스를 만들어보자 일단 먼저 알아야할 것은 상속에 대한 두 가지 규칙인데

1. 서브 클래스는 슈퍼 클래스에 존재하는 속성과 '같은 이름'의 속성을 가질 수 없다.
2. 서브 클래스가 생성될 때는 반드시 슈퍼클래스의 생성자까지 호출되어야 한다

Dog클래스를 만들때는 생성자에서 이름과 나이를 받긴 하지만 클래스의 자체 속성으로 만들어주는 var을 붙이지 말고 일반 패러미터로 받아 Animal 클래스의 생성자에 직접 넘겨주도록 하자 클래스의 상속은 클래스 선언 뒤에 콜론을 붙이고 생성자를 호출할 수 있도록 해주면 된다. 생성자의 패러미터로 받은 이름과 나이 그리고 "개"라는 종류는 Dog클래스라면 공통된 값이므로 고정된 값으로 넘기도록 하겠다. 이렇게 하면 Animal클래스에 이름과 나이, 그리고 '개'라는 종류를 넣어 생성한  a인스턴스와  Dog 클래스에 이름과 나이만 넣어 생성한 b인스턴스가 같은 속성과 함수의 기능을 갖게되겠쥬? 따라서 두 인스턴스에 자기소개를 시켜보면 같은 결과가 나오는 것을 볼 수 있다.

```kotlin
fun main() { 
   var a = Animal("별이", 5, "개")
   var b = Dog("별이", 5)
   
  a.introduce()
  b.introduce()
}
open class Animal (var name:String, var age:Int, var type:String)
{
   fun introduce() {
       println ("저는 ${type}이고 ${name}이고, ${age}살 입니다.")
   }
}
class Dog (name:String, age:Int) : Animal (name, age, "개")
{

}
```

그런데 이렇게만 하면 의미가 없겠죠? Dog만의 함수를 추가해줄 순 없을까? 당연히 가능하다 Dog안에 짖는 함수인 bark를 추가해보자 그리고 멍멍 짖는 내용을 출력해보자 이 함수는 Dog 클래스 안에서만 사용할 수 있기 때문에 b인스턴스에 bark를 시켜보면 강아지가 멍멍 짖는 것을 확인할 수 있다 이번엔 Cat클래스도 만들어보자 Dog랑 똑같이 이름과 나이를 받고 이름,나이,"고양이"라는 값을 슈퍼 클래스에 넘겨준다. 그리고 meow라는 함수를 넣어 야옹을 시켜보자 cat의 인스턴스를 만들고 자기소개와 meow를 시켜보면 잘 실행되는 것을 볼 수 있다.

```kotlin
fun main() { 
   var a = Animal("별이", 5, "개")
   var b = Dog("별이", 5)
   
  a.introduce()
  b.introduce()

  b.bark()

 var c = Cat("루이", 1)
 
 c.introduce()
 c.meow()
}
open class Animal (var name:String, var age:Int, var type:String)
{
   fun introduce() {
       println ("저는 ${type}이고 ${name}이고, ${age}살 입니다.")
   }
}
class Dog (name:String, age:Int) : Animal (name, age, "개")
{
    fun bark() {
         println("멍멍")
     }
}

class Cat (name:String, age:Int) : Animal (name, age, "고양이")
{
   fun meow() {
        println("야옹야옹")
   }
}
```

클래스의 상속은 클래스를 더 구조적으로 다룰 수 있게 해준다는 장점이 있지만 지나친 상속구조는 코드를 더 어렵게 만드는 점도 기억하자!
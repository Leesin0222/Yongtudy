먼저 코드의 흐름을 제어할 수 있는 키워드를 알아볼텐데요 이 중 하나인 **return**은 함수를 배울 때 이미 사용했듯이 '함수를 종료'하고 값을 '반환'하는 역할을 하고 있다. 그러면 흐름을 제어하는 다른 키워드는 무엇이 있을까?

바로 반복문에 사용할 수 있는 **break continue**이다.

**break**는 반복문 내의 구문이 실행되는 중간에 즉시 반복문을 '종료'하고 다음 구문으로 넘어가는 역할을 하며

**continue**는 다음 조건반복으로 즉시 넘어가는 역할을 한다 실제 코드를 수행해보자 for문을 하나 만드로 i를 1에서 10까지 반복해보자 그리고 for문 내에서 if문을 하나 만들어 i가 3이면 break를 수행하도록 하고 그 다음줄에 println으로 i를 출력해보자 이 코드는 i가 3이 되는 시점에 반복이 즉시 중단되기 때문에 실행시켜 보면 1과 2가 찍힌 후 정지되는 것을 볼 수 있다.

```kotlin
fun main() {
   for (i in 1..10) {
       if (i == 3) break
       println(i)
   }
}
```

이번엔 break 대신 continue를 넣어보자 이 코드는 i가 3이 되는 시점에 println을 하지 않고 바로 for문으로 돌아가 다음 반복 조건인 4로 진행되기 때문에 실행시켜 보면 3을 제외한 모든 숫자가 찍히게 된다.

```kotlin
fun main() {
   for (i in 1..10) {
       if (i == 3) continue
       println(i)
   }
}
```

여기까지는 사실 기존의 언어들이랑 비슷한데 코틀린을 여기에 한 가지 기능이 더 추가되었다. 바로 다중 반복문에서 break나 continue가 적용되는 반복문을 label을 통해 지정할 수 있는 기능인데 예를 들어 i로 10번을 반복하는 for문 내에서 다시 j로 10번을 반복하는 구조의 다중 반복문이 있다고 해보자 여기서 i가 1이고 j가 2면 모든 반복문을 종료해야 한다고 해보자 고전적인 언어에서는 내부 반복문에서 조건을 체크하여 break를 하더라도 외부 반복문에서 또 다시 조건을 체크하여 모든 반복문을 수동으로 종료해야만 했는데 코틀린에서는 외부 반복문에 레이블 이름과 @기호를 달고  break문에서 @과 레이블 이름을 달아주면 레이블이 달린 반복문을 기준으로 즉시 break를 시켜준다 물론 continue인 경우에도 마찬가지이다 그럼 루틴이 제대로 작동하는지 내부반복문에 println을 통해 i와 j값을 찍어보자 참고로 따옴표 안에서 변수를 출력할 때는 변수명 앞에 달러표기를 붙여주면 변수 내용으로 대체되어 출력된다. 실행해 보시면 i가 1이고 j가 1일 때까지만 출력되고 그 다음에는 break가 수행되었음을 알 수 있다.

```kotlin
fun main() {
   loop@for (i in 1..10) {
       for (j in 1..10) {
            if(i == 1 && j == 2)break@loop
            println ("i:$i, j:$j)
         }
    }
}
```

그럼 방금 봤던 예제에서 사용된 논리연산자에 대해서 알아볼까요?

**논리연산자(logical operators)**는 논리 값을 연산하여 새로운 논리값을 도출 할 때 쓰는 연산자이다 논리연산자에는 *&&기호를 두 개쓰는 and연산자*  *||기호를 두개쓰는 or연산자* *그리고 !를 사용하는 not연산자* 가 있다

and(&&)연산자는 and값 앞 뒤에 있는 값들이 모두 true일 때 결과값이 true가 되는 연산자이다.

> true && true ⇒ true

or(||)연산자는 앞 뒤에 있는 논리값들이 둘 중 하나라도 true라면 결과값이 true가 된다

> true || false ⇒ true

not(!)연산자는 뒤에 붙는 값을 반전시킨다.

> !true ⇒ false     !false ⇒ true

실제 예제를 통해 확인해보자 println안에 참과 거짓을 and하는 경우와 두 개를 or하는 경우를 넣어보고 또한 참과 거짓에 각각 not을 붙인 경우를 실행해보자

```kotlin
fun main() {
   println (true && false)
   println (true || false)
   println (!true)
   println (!false)
}
```

예상대로 and(&&)연산자는 false   or(||)연산자는 true를 반환하쥬? 또한 !true와 !false는 각각 false와 true가 됨을 볼 수 있다. 지금은 boolean 리터럴 값으로만 수행했지만 실제 사용시에는 조건식과 조건식을 연산하는 경우가 더 많다

이번엔 변수 a와 b에 각각 6과 4를 할당해보자 그리고 a와 b를 각각 5와 비교하는 조건식을 and연산 해보자 앞에 있는 식은 true,뒤에 있는 식은 false이므로 실행해보면 false가 나오는 것을 볼 수 있다.

```kotlin
fun main() {
   var a = 6
   var b = 4
   println (a> 5 && b>5)
}
```

예제에서는 결과값을 눈으로 보여주기 위해  println을 사용했지만 실제 비교연산은 흐름제어에서의 예시에서 보았듯이 조건문인 if와 같이 쓰이게 된다 if(i==1 && j==2)break

프로그램에서는 2개 이상의 조건식을 고려하여 분기해야하는 경우가 많기 때문이다

흐름제어 및 논리연산자는 복잡한 조건에 따라 반복을 제어하고 분기를 실행해야 하는 경우에 많이 쓰이므로 꼭 알길 바란다
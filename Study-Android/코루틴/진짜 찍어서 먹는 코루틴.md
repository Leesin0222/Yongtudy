# 코루틴

이번에는 코루틴에 대해 찍먹(그냥 찍먹은 아니고 진짜 찍어서 먹어버리는..)해보겠다. 코루틴은 비동기 프로그래밍을 위해 권장되는 솔루션이다. 다음은 코루틴의 장점들(주목할 만한 기능들)이다.

+ **경량**: 코루틴을 실행 중인 스레드를 차단하지 않는 `정지`를 지원하므로 단일 스레드에서 많은 코루틴을 실행할 수 있다. 정지는 많은 동시 작업을 지원하면서도 차단보다 메모리를 절약한다.

  > ```kotlin
  > fun main() = runBlocking { //CoroutineScope
  >     launch { // 새 코루틴을 launch하고 계속한다.
  >         delay(1000L) // 1초 동안 비차단 지연 (기본 시간 단위는 ms)
  >         println("World!") // delay후 pirnt됨
  >     }
  >     println("Hello") //메인 코루틴은 이전 코루틴이 delay되는 동안 계속된다.
  > }
  > 
  >                        /*결과 >> Hello World!*/
  > ```

+ **메모리 누수 감소**: `구조화된 동시 실행`을 사용하여 범위 내에서 작업을 실행한다.

  > **구조적 동시성**
  >
  > 코루틴은 구조화된 동시성의 원칙을 따른다. 즉, 새로운 코루틴은 코루틴의 수명을 제한하는 특정 CoroutineScope에서만 시작될 수 있다. 위의 예는 runBlocking이 해당 범위를 설정하고 이전 예가 World!가 1초 지연 후에 인쇄 될 때까지 기다렸다가 종료 된다는 것을 보여준다. 
  >
  > 실제 Application에서는 많은 코루틴을 시작하게 된다. 구조적 동시성은 손실되지 않고 누출되지 않도록 한다. 외부 범위는 모든 하위 코루틴이 완료될 때까지 완료할 수 없다. 구조적 동시성은 또한 코드의 모든 오류가 적절하게 보고되고 손실되지 않도록 한다.

+ **기본으로 제공되는 취소를 지원한다**: 실행 중인 코루틴 계층 구조를 통해 자동으로 취소가 전달된다.

  > **코루틴 실행 취소**
  >
  > 장기 실행 Application에서는 백그라운드 코루틴에 대한 세밀한 제어가 필요할 수 있다. 예를 들어, 유저가 코루틴을 시작한 페이지를 닫았을 수 있으며 이제 그 결과가 더 이상 필요하지 않으며 작업을 취소할 수 있다. launch함수는 반환 Job실행중인 코루틴을 취소 할 수 있다.
  >
  > ```kotlin
  > fun main() = runBlocking {
  > 	val job = launch {
  >     	repeat(1000) { i ->
  >         	println("job: I'm sleeping $i ...")
  >         	delay(500L)
  >          }
  >     }
  > 	delay(1300L) // 조금 지연
  > 	println("main: I'm tired of waiting!")
  > 	job.cancel() // job을 취소한다.
  > 	job.join() // job이 완료될 때까지 기다린다.
  > 	println("main: Now I can quit.")
  > }
  >                  /* 결과
  >  	               job: I'm sleeping 0 ...
  > 				  job: I'm sleeping 1 ...
  > 	               job: I'm sleeping 2 ...
  > 			      main: I'm tired of waiting!
  > 			      main: Now I can quit.       */
  > ```
  >
  > main이 호출되자마자 job.cancel로 인해 취소되었기 때문에 다른 코루틴의 출력을 볼 수 없다. 우리는 취소되었기 때문에 다른 코루틴의 출력을 볼 수 없다. cancel 및 join 호출을 결합하는 Job 확장 기능 함수인 cancelAndJoin도 있다.

+ **Android Jetpack통합**: 많은 Jetpack 라이브러리에 코루틴을 완전히 지원하는 `확장 프로그램`이 포함되어있다. 일부 라이브러리는 구조화된 동시 실행에 사용할 수 잇는 자체 코루틴 범위도 제공한다고 한다.

  > **Android KTX**
  >
  > Android KTX는 안드로이드 Jetpack과 기타 Android 라이브러리에 포함되어있는 Kotlin 확장 프로그램 세트이다. KTX확장 프로그램은 간결하고 직관적인 Kotlin을 Jetpackl, Android 플랫폼, 기타 API에 제공한다. 이를 위해 다음을 비롯한 여러 Kotlin언어 기능을 활용한다.
  >
  > + 확장 함수, 확장 속성, 람다, 이름이 지정된 매개변수, 매개변수 기본값, 코루틴



-----------------

## 예시 개요

이 예제에서는 앱아키텍처 가이드 (MVVM)에 따라 네트워크 요청을 보내고 결과를 기본 스레드로 반환한다. 그러면 앱에서 결과를 사용자에게 표시할 수 있다.

특히 ViewModel 아키텍쳐 구성요소는 기본 스레드의 저장소 레이어를 호출하여 네트워크 요청을 트리거한다. 이 가이드에서는 코루틴을 사용하는 다양한 솔루션을 반복하여 기본 스레드를 차단 해제 상태로 유지하겠다.

ViewModel에는 코루틴과 직접 연동되는 KTX확장 프로그램 집합이 포함된다. 이러한 확장 프로그램은 lifecycle-viewmodel-ktx라이브러리이며, 이 예제에서 사용된다.



## Gradle에 추가

Android 프젝에서 코루틴을 사용하려면 앱의 build.gradle파일에 다음의 종속 항목을 추가해야한다.

```kotlin
dependencies {
	implementation("org.jetbrains,kotlinx:kotlinx-coroutines-android:1.4.0")
}
```



## 백그라운드 스레드에서 실행

기본 스레드에서 네트워크 요청을 보내면 응답을 받을 때까지 스레드가 대기를 해야하거나 차단된다. 스레드가 차단되는 경우에는 이로 인해 OS가 onDraw()를 호출할 수 없으므로 앱이 정지되고 애플리케이션에 응답 없음(ANR)대화상자가 표시될 수 있다. 사용자 환경을 개선하기 위해 백그라운드 스레드에서 이 작업을 실행해 보겠다.

먼저 Repository클래스를 보고 네트워크 요청 방식을 확인해보자!

```kotlin
sealed class Result<out R> {
    data class Success<out T>(val data: T) : Result<T>()
    data class Error(val exception: Exception) : Result<Nothing>()
}

class LoginRepository(private val responseParser: LoginResponseParser) {
    private const val loginUrl = "https://example.com/login"

    // 현재 스레드를 blocking하면서 네트워크를 요청하는 함수
    fun makeLoginRequest(
        jsonBody: String
    ): Result<LoginResponse> {
        val url = URL(loginUrl)
        (url.openConnection() as? HttpURLConnection)?.run {
            requestMethod = "POST"
            setRequestProperty("Content-Type", "application/json; utf-8")
            setRequestProperty("Accept", "application/json")
            doOutput = true
            outputStream.write(jsonBody.toByteArray())
            return Result.Success(responseParser.parse(inputStream))
        }
        return Result.Error(Exception("Cannot open HttpURLConnection"))
    }
}
```

makeLoginRequest가 동기식으로 호출 스레드를 차단한다. 네트워크 요청의 응답을 모델링하기 위해 자체 Result 클래스를 사용한다.

다음으로 ViewModel은 예를 들어서 유저가 버튼을 클릭할 때 네트워크 요청을 트리거한다.

```kotlin
class LoginViewModel(
	private val loginRepository: LoginRepository
) : ViewModel() {
    fun login(username:String, token:String) {
        val jsonBody = "{ username: \"$username\", token: \"$token\"}"
        loginRepository.makeLoginRequest(jsonBody)
    }
}
```

위의 코드를 보면 LoginViewModel은 네트워크 요청을 보낼 때 UI 스레드를 차단한다. 이 실행을 기본 스레드 외부로 이동하는 가장 간단한 방법은 새로운 코루틴을 만들고 I/O 스레드에서 네트워크 요청을 실행하는 것이다.

그럼 이제 아래를 봐보자!

```kotlin
class LoginViewModel(
    private val loginRepository: LoginRepository
): ViewModel() {

    fun login(username: String, token: String) {
        // UI스레드에서 이동해 실행을 할 새로운 코루틴 작성
        viewModelScope.launch(Dispatchers.IO) {
            val jsonBody = "{ username: \"$username\", token: \"$token\"}"
            loginRepository.makeLoginRequest(jsonBody)
        }
    }
}
```

login 함수에서 코루틴 코드를 파헤쳐보자!

+ viewModelScope는 ViewModel KTX확장 프로그램에 포함된 사전 정의된 CoroutineScope이다. 모든 코루틴은 범위 안에서 실행해야한다. CoroutineScope는 하나 이상의 관련 코루틴을 관리해준다.
+ lauch는 코루틴을 만들어주고 함수 본문의 실행에 해당하는 Dispatcher에 전달하는 함수이다.
+ Dispatchers.IO는 이 코루틴을 I/O 작업용으로 예약된 스레드에서 실행되야 함을 나타낸다.

login 함수는 다음과 같이 실행된다.

1. 앱이 기본 스레드의 View레이어에서 login함수를 호출한다.
2. lauch가 새 코루틴을 만들며, I/O 작업용으로 예약된 스레드에서 독립적으로 네트워크 요청이 이루어진다.
3. 코루틴이 실행되는 동안 네트워크 요청이 완료되기 전에 login함수가 계속 실행되어 결과를 반환한다. 편의를 위해 지금은 네트워크 응답을 무시한다.

이 코루틴은 viewModelScope로 시작되므로 ViewModel 범위에서 실행된다. 유저가 화면 밖으로 이동하는 것으로 인해 ViewMdoel이 소멸되는 경우 viewModelScope가 자동으로 취소되고 실행 중인 모든 코루틴도 취소되게 된다.

위의 예제에서 한 가지 문제는 makeLoginRequest를 호출하는 모든 항목이 명시적으로 실행을 기본 스레드 외부로 이동해야 한다는 것이다. 이 문제를 해결하기 위해 Repository를 수정하는 방법을 알아보자!



## 기본 안전을 위해 코루틴을 사용

기본 스레드에서 UI업데이트를 차단하지 않는 함수를 기본 안전 함수로 간주한다. 기본 스레드에서 makeLoginRequest를 호출하면 UI가 차단되므로 makeLoginRequest 함수는 기본 안전 함수가 아니다. 코루틴 라이브러리의 withContext() 함수를 사용하여 코루틴 실행을 다른 스레드로 이동한다.

```kotlin
class LoginRepsitory(...) {
    ...
    suspend fun makeLoginRequest(
    	jsonBody : String
    ): Result<LoginResponse> {
        //코루틴 실행을 I/O dispatcher로 이동한다.
        return wtihContext(Dispatchers.IO) {
			//Blocking(차단한다.) 네트워크 요청 코드
        }
    }
}
```

withContext(Dispatchers.IO)는 코루틴 실행을 위해 I/O 스레드롤 이동하여 호출 함수를 기본 안전 함수로 만들고 필요에 따라 UI를 업데이트하도록 설정한다.

makeLoginRequest에는 suspend키워드도 표시된다. 이 키워드는 코루틴 내에서 함수가 호출되도록 강제하는 Kotlin의 방법이다.

다음 예에서는  LoginViewModel에 코루틴을 생성한다. makeLoginRequest가 실행을 기본 스레드 외부로 이동하므로, 이제 login함수의 코루틴이 기본 스레드에서 실행될 수 있다.

```kotlin
class LoginViewModel(
    private val loginRepository: LoginRepository
): ViewModel() {
    fun login(username : String, token : Stirng) {
        //UI 스레드에 새 코루틴을 작성한다.
        viewModelScope.launch {
            val jsonBody = "{ username: \"$username\", token: \$token\}"
            
            //네트워크 호출을 수행하고 완료될 때까지 실행을 일시 중단한다.
            val result = loginRepository.makeLoginRequest(jsonBody)
            
            //사용자에게 네트워크를 요청한 결과이다.
            when (result) {
                is Result.Success<LoginResponse> -> //Happy path
                else -> //UI안의 error를 보여준다.
             }
        }
    }
}
```

makeLoginRequest가 suspend 함수이므로 코루틴은 여전히 필요하며, 모든 suspend함수는 코루틴에서 실행되야한다.

이 코드는 위의 login예와 몇 가지의 차이점이 존재한다.

+ launch가 Dispatchers.IO매개변수를 사용하지 않는다. Dispatcher을 launch에 전달하지 않으면 viewModelScope에서 실행된 코루틴은 기본 스레드에서 실행된다.
+ 네트워크 요청의 결과가 이제 성공 또는 실패 UI를 표시하도록 처리된다.

이제 로그인 함수가 다음과 같이 실해된다.

+ 앱이 기본 스레드의 View레이어에서 login() 함수를 호출한다.
+ launch가 기본 스레드에서 네트워크 요청을 보낼 때 새 코루틴을 만들며, 코루틴이 실행을 시작한다.
+ 코루틴 내에서 이제 loginRepository.makeLoginRequest() 호출은 makeLoginRequest()의 withContext 블록 실행이 끝날 때까지 코루틴의 추가 실행을 정지한다.
+ withContext블록이 완료되면 login() 의 코루틴이 네트워크 요청의 결과와 함께 기본 스레드에서 실행을 재개한다.



## 예외 처리

Repository 레이어에서 발생할 수 있는 예외를 처리하려면 Kotlin에서 기본으로 제공하는 예외 지원을 사용한다. 다음 예에서는  try-catch 블록을 사용한다.

```kotlin
class LoginViewModel(
    private val loginRepository: LoginRepository
): ViewModel() {

    fun makeLoginRequest(username: String, token: String) {
        viewModelScope.launch {
            val jsonBody = "{ username: \"$username\", token: \"$token\"}"
            val result = try {
                loginRepository.makeLoginRequest(jsonBody)
            } catch(e: Exception) {
                Result.Error(Exception("Network request failed"))
            }
            when (result) {
                is Result.Success<LoginResponse> -> // Happy path
                else -> // UI 안에 error을 보여준다.
            }
        }
    }
} 
```

이 예에서는 makeLoginRequest() 호출에 의해 발생한 예기치 않은 예외가 UI에서 오류로 처리된다.







